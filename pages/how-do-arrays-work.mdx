---
title: 'How do arrays work?'
blurb: 'Diving into the most popular data structure.'
description: "It's a bit more than a website."
publishedAt: '2021-06-21'
editedAt: '2021-06-21'
---

import Placeholder from '@/components/utils/Placeholder'
import Callout from '@/elements/Callout'

import Array from '@/components/how-arrays-work/Array'

## TODOS

- [ ] Array visualizations
- [ ] Memory lib
- [ ] Interactive number slider
- [ ] Function param annotations

This is an array:

<Array />

It represents a list of items. If you know the index of the item you're looking for, you can find the item in the array pretty quickly.

<Placeholder name="array lookup" />

In JavaScript (and other dynamic-type languages), you can even put different pieces of data in the same array:

<Placeholder name="multi-type arrays" />

But how does this all work? What's going on "under the hood" when you lookup an item in an array? How is it so fast anyway? In this post, we're going to dive into the inner workings of an array by building one our own using a couple memory primitives.

## Memory API

Before we get started, let's look at what memory APIs are available to us. If you're not super familiar with how computer memory works, don't worry — think of it as a super long array of bytes:

<Placeholder name="memory list" />

Each byte has an associated address, so you can read data from memory just by referencing its address:

```js
const item = Mem.get(/* address */ 0x123)
```

<Placeholder name="memory access" />

Likewise, you can use the address to store data too:

```js
Mem.set(/* address */ 0x123, /* value */ 12)
```

<Placeholder name="memory storage" />

<Callout label="Arrays... with arrays?">

It might seem pretty weird that we're describing arrays using arrays, but don't worry! Memory is built into the hardware so in that sense it "just works".

</Callout>

One thing to keep in mind is that you can't freely store data anywhere in memory you'd like — both the hardware and the operating system won't let you!\* Instead, you have to _allocate_ the space in memory first.

> \*And for good reason too — your computer memory is shared between the hundreds of different programs that are running at the same time. Imagine if programs are able to change the memory that's being used by other programs!

```js
const pointer = Mem.allocate(/* num of bytes */ 12)
```

Allocating memory returns a pointer, an object that, among other things, represents the address of the **first byte** that you allocated:

<Placeholder name="memory and pointers" />

Once you've allocated memory, you can freely read and write to it:

<Placeholder name="read and write to allocated memory" />

But if you try to read and write to memory that's not allocated yet, it's not going to work:

<Placeholder name="read to non-allocated memory" />

<Callout label="Fake Memory">

Here, trying to write to a space that's not yours only triggers an error animation. If you try to write to a space in your actual computer memory that wasn't allocated (using C, for example) you would trigger the dreaded SEGFAULT error and your program's going to crash.

</Callout>

Finally, once you're done with the data and don't need it anymore, you can free up that space so the computer can use the memory for other things:

```js
const pointer = Mem.allocate(/* num of bytes */ 12)

// do stuff

Mem.free(pointer)
```

<Placeholder name="freeing memory" />

But be careful! Once you've freed a memory location, you can't read from that location anymore because it's no longer allocated. Trying to do so will trigger another crash:

```js
const pointer = Mem.allocate(/* num of bytes */ 12)

// do stuff

Mem.free(pointer)
const item = Mem.get(pointer) // oops!
```

<Placeholder name="read from freed memory" />

One thing you might notice from this allocate-free workflow is that you end up not referencing addresses directly. You just need to work with pointers and move them around.

Quick summary:

- Memory, for our purposes, is a long array of bytes where each byte has an associated address
- To use memory, you need to allocate it first; this allocation process returns a pointer, the address of the first byte that you allocated
- Once allocated, you can freely read and write to that memory location
- When you're done, you can free the allocated space so it can be used elsewhere

## Building the Array

Back to arrays! Let's start off with a couple assumptions for simplicity:

1. The array has a fixed length (i.e. it cannot grow in size)
2. The array can only contain numbers

These assumptions may not make too much sense right now, but don't worry — we'll ease them as we move on.

### Allocating Space

With these assumptions, how would we lay out the array in memory? The simplest way would be to lay out the array as one big continuous block:

<Placeholder name="array block" />

This works for now, so let's see how we can use the memory API we described earlier to make it happen. Remember that the first thing we have to do is to allocate space for it first. To allocate space, we need to know how many bytes we need:

```js
const data = Mem.allocate(/* num of bytes */)
```

Since our array is a fixed length and can only contain numbers, we can determine the total number of bytes we need using a simple formula:

```
total # of bytes = length x (# of bytes for 1 number)
```

In JavaScript, numbers are 8 bytes in size, so we'll use 8 for the number of bytes for 1 number. This gives the total space needed as 8 multiplied by the length of the array:

<Placeholder name="allocate array" />

### Reading and Writing

Once allocated, we're free to read and write data to the array. In particular, reading and writing might look something like this:

```js
arr.set(/* index */ 0, /* value */ 2)
const item = arr.get(/* index */ 0) // item = 2
```

To implement this, we need to keep two things in mind:

1. As long as you have the address, you can quickly read and write to and from memory
2. Allocating the array gives us the address for the _first_ byte we allocated

To quickly get the item at a particular index, we need to determine the address of the item at that index. How can we determine the address given the address of the first byte only?

For index 0, we already have the address — it's exactly the address that was returned from the allocate function!

<Placeholder name="read index 0" />

For other indices, we have to do a bit of math. Since we know the size of each item in the array, the address of the item at index `i` is:

```
address of index i = address at index 0 + (size of item * i)
```

In our case, the size of each item is the size of a number, 8 bytes. So our formula is then:

```
address of index i = address at index 0 + (8 * i)
```

<Placeholder name="read from index i" />

And this is why arrays are fast! Using the index, we can derive the address that we need without needing to go through every element of the array.

## Growing the Array

## Mixing Types
